NewtonianFrame N
RigidBody R %Robot
RigidBody P %Prehenseur
RigidBody RW %Roue Arriere
RigidBody FW %Roue Avant
%RigidBody E %Pendule
Particle B %Batterie
Particle M %Moteur
Particle S  %Sapin
%Point EP (E)
System S1(R,B,M,RW,FW)
System S2(P,S) 
Constant MasseRobot
Constant MasseBatterie
Constant MasseMoteur
Constant MassePrehenseur
Constant MasseSapin
Constant MasseRW
Constant MasseFW
Constant MassePendule
Constant LongueurPendule
Constant HauteurSapin
Constant g
Constant ho
Constant torque
Constant VitAngulaire
Constant distRWM %distance entre le RW et le milieu du robot
Constant distSolRail %distance entre le sol et le rail
Constant distRailM %distance entre le rail et le milieu du robot
Constant diametreRoue %diametre des roues
Constant distBatMilieu %distance entre la batterie et le milieu du robot
Constant distMotMilieu %distance entre le moteur et le milieu du robot
Constant longrobot %longueur du robot
Constant InertieRW = (0.5 * MasseRW * diametreRoue^2) %inertie de la roue arriere
Constant InertieFW = (0.5 * MasseFW * diametreRoue^2) %inertie de la roue avant
Constant InertieP = (0.5 * MassePrehenseur * diametreRoue^2) %inertie du prehenseur
Variable q'',fg,fd,Nd,Ng,tension,X''
R.SetMass(MasseRobot) %Ajout de la masse du robot
P.SetMass(MassePrehenseur) %Ajout de la masse du prehenseur
B.SetMass(MasseBatterie) %Ajout de la masse de la batterie
M.SetMass(MasseMoteur) %Ajout de la masse du moteur
S.SetMass(MasseSapin) %Ajout de la masse du sapin
RW.SetMass(MasseRW) %Ajout de la masse de la roue arriere
FW.SetMass(MasseFW) %Ajout de la masse de la roue avant
%E.SetMass(MassePendule) %Ajout de la masse du pendule
RW.SetInertia(RWcm,0,0,InertieRW) %Ajout de l'inertie de la roue arriere
FW.SetInertia(FWcm,0,0,InertieFW) %Ajout de l'inertie de la roue avant
P.SetInertia(Pcm,0,0,InertieP) %Ajout de l'inertie du prehenseur sinon ca ne voualit pas compiler
RW.SetAngularVelocity(N,VitAngulaire*nz>) %Ajout de la vitesse angulaire de la roue arriere
FW.SetAngularVelocity(N,VitAngulaire*nz>) %Ajout de la vitesse angulaire de la roue avant
R.RotateZ(N,0)
R.SetAngularVelocityAcceleration(N,0>)
FW.RotateZ(N,0)
RW.RotateZ(N,0)
P.RotateZ(N,q)
Ro.Translate(No,X*nx>)
%Eo.Translate(Rcm, 0>)
%Ecm.Translate(Eo,-LongueurPendule*ey>)
%EP.Translate (Pcm,0>)
Rcm.Translate(Ro,longrobot/2*rx>)
RWcm.Translate(Rcm,-distRWM*rx>)
Rwo.Translate(RWcm,-diametreRoue/2*ry>)
FWcm.Translate(Rcm,distRWM*rx>)
Fwo.Translate(FWcm,-diametreRoue/2*ry>)
Pcm.Translate(Rcm,-LongueurPendule*py>)
S.Translate(Pcm,-HauteurSapin/2*py>)
B.Translate(Rcm,distBatMilieu*rx>)
M.Translate(Rcm,-distMotMilieu*rx>)
VT> = Rcm.Getunitvector(Pcm)
%AddForces
Rcm.AddForce(tension*VT>)
Rcm.AddForce(-MasseRobot*g*ny>)
Pcm.AddForce(-tension*VT>)
Pcm.AddForce(-MassePrehenseur*g*ny>)
RWcm.AddForce(-MasseRW*g*ny>)
FWcm.AddForce(-MasseFW*g*ny>)
Fwo.AddForce(Ng*ny>)
Rwo.AddForce(Nd*ny>)
Rwo.AddForce(fg*ny>)
Fwo.AddForce(fd*ny>)
S.AddForce(-MasseSapin*g*ny>)
B.AddForce(-MasseBatterie*g*ny>)
M.AddForce(-MasseMoteur*g*ny>)
%Ecm.AddForce(-MassePendule*g*ny>)
%Eo.AddForce(-tension*VT>)
%EP.AddForce(tension*VT>)
%AddTorques
RW.AddTorque(torque*nz>)
%Ã‰quations
eq[1] = dot(S1.Getdynamics(),nx>)
eq[2] = dot(S1.Getdynamics(),ny>)
eq[3] = dot(S1.Getdynamics(Rcm),nz>)
eq[4] = dot(S2.Getdynamics(),nx>)
eq[5] = dot(S2.Getdynamics(),ny>)
eq[6] = dot(S2.Getdynamics(Pcm),nz>)
eq[7] = EP.GetDistance(Rcm) - LongueurPendule
