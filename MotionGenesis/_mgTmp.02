   (1) NewtonianFrame N
   (2) RigidBody R %Robot
   (3) RigidBody P %Prehenseur
   (4) RigidBody RW %Roue Arriere
   (5) RigidBody FW %Roue Avant
   (6) %RigidBody E %Pendule
   (7) Particle B %Batterie
   (8) Particle M %Moteur
   (9) Particle S  %Sapin
   (10) %Point EP (E)
   (11) System S1(R,B,M,RW,FW)
   (12) System S2(P,S) 
   (13) Constant MasseRobot
   (14) Constant MasseBatterie
   (15) Constant MasseMoteur
   (16) Constant MassePrehenseur
   (17) Constant MasseSapin
   (18) Constant MasseRW
   (19) Constant MasseFW
   (20) Constant MassePendule
   (21) Constant LongueurPendule
   (22) Constant HauteurSapin
   (23) Constant g
   (24) Constant ho
   (25) Constant torque
   (26) Constant VitAngulaire
   (27) Constant distRWM %distance entre le RW et le milieu du robot
   (28) Constant distSolRail %distance entre le sol et le rail
   (29) Constant distRailM %distance entre le rail et le milieu du robot
   (30) Constant diametreRoue %diametre des roues
   (31) Constant distBatMilieu %distance entre la batterie et le milieu du robot
   (32) Constant distMotMilieu %distance entre le moteur et le milieu du robot
   (33) Constant longrobot %longueur du robot
   (34) Constant InertieRW = (0.5 * MasseRW * diametreRoue^2) %inertie de la roue arriere
-> (35) InertieRW = 0.5*MasseRW*diametreRoue^2

   (36) Constant InertieFW = (0.5 * MasseFW * diametreRoue^2) %inertie de la roue avant
-> (37) InertieFW = 0.5*MasseFW*diametreRoue^2

   (38) Constant InertieP = (0.5 * MassePrehenseur * diametreRoue^2) %inertie du prehenseur
-> (39) InertieP = 0.5*MassePrehenseur*diametreRoue^2

   (40) Variable q'',fg,fd,Nd,Ng,tension,X''
   (41) R.SetMass(MasseRobot) %Ajout de la masse du robot
   (42) P.SetMass(MassePrehenseur) %Ajout de la masse du prehenseur
   (43) B.SetMass(MasseBatterie) %Ajout de la masse de la batterie
   (44) M.SetMass(MasseMoteur) %Ajout de la masse du moteur
   (45) S.SetMass(MasseSapin) %Ajout de la masse du sapin
   (46) RW.SetMass(MasseRW) %Ajout de la masse de la roue arriere
   (47) FW.SetMass(MasseFW) %Ajout de la masse de la roue avant
   (48) %E.SetMass(MassePendule) %Ajout de la masse du pendule
   (49) RW.SetInertia(RWcm,0,0,InertieRW) %Ajout de l'inertie de la roue arriere
   (50) FW.SetInertia(FWcm,0,0,InertieFW) %Ajout de l'inertie de la roue avant
   (51) P.SetInertia(Pcm,0,0,InertieP) %Ajout de l'inertie du prehenseur sinon ca ne voualit pas compiler
   (52) RW.SetAngularVelocity(N,VitAngulaire*nz>) %Ajout de la vitesse angulaire de la roue arriere
-> (53) w_RW_N> = VitAngulaire*Nz>

   (54) FW.SetAngularVelocity(N,VitAngulaire*nz>) %Ajout de la vitesse angulaire de la roue avant
-> (55) w_FW_N> = VitAngulaire*Nz>

   (56) R.RotateZ(N,0)
-> (57) R_N = [1, 0, 0;  0, 1, 0;  0, 0, 1]
-> (58) w_R_N> = 0>
-> (59) alf_R_N> = 0>

   (60) R.SetAngularVelocityAcceleration(N,0>)
-> (61) w_R_N> = 0>
-> (62) alf_R_N> = 0>

   (63) FW.RotateZ(N,0)
-> (64) FW_N = [1, 0, 0;  0, 1, 0;  0, 0, 1]
-> (65) w_FW_N> = 0>
-> (66) alf_FW_N> = 0>

   (67) RW.RotateZ(N,0)
-> (68) RW_N = [1, 0, 0;  0, 1, 0;  0, 0, 1]
-> (69) w_RW_N> = 0>
-> (70) alf_RW_N> = 0>

   (71) P.RotateZ(N,q)
-> (72) P_N = [cos(q), sin(q), 0;  -sin(q), cos(q), 0;  0, 0, 1]
-> (73) w_P_N> = q'*Pz>
-> (74) alf_P_N> = q''*Pz>

   (75) Ro.Translate(No,X*nx>)
-> (76) p_No_Ro> = X*Nx>
-> (77) v_Ro_N> = X'*Nx>
-> (78) a_Ro_N> = X''*Nx>

   (79) %Eo.Translate(Rcm, 0>)
   (80) %Ecm.Translate(Eo,-LongueurPendule*ey>)
   (81) %EP.Translate (Pcm,0>)
   (82) Rcm.Translate(Ro,longrobot/2*rx>)
-> (83) p_Ro_Rcm> = 0.5*longrobot*Rx>
-> (84) v_Rcm_N> = X'*Nx>
-> (85) a_Rcm_N> = X''*Nx>

   (86) RWcm.Translate(Rcm,-distRWM*rx>)
-> (87) p_Rcm_RWcm> = -distRWM*Rx>
-> (88) v_RWcm_N> = X'*Nx>
-> (89) a_RWcm_N> = X''*Nx>

   (90) Rwo.Translate(RWcm,-diametreRoue/2*ry>)
-> (91) p_RWcm_RWo> = -0.5*diametreRoue*Ry>
-> (92) v_RWo_N> = X'*Nx>
-> (93) a_RWo_N> = X''*Nx>

   (94) FWcm.Translate(Rcm,distRWM*rx>)
-> (95) p_Rcm_FWcm> = distRWM*Rx>
-> (96) v_FWcm_N> = X'*Nx>
-> (97) a_FWcm_N> = X''*Nx>

   (98) Fwo.Translate(FWcm,-diametreRoue/2*ry>)
-> (99) p_FWcm_FWo> = -0.5*diametreRoue*Ry>
-> (100) v_FWo_N> = X'*Nx>
-> (101) a_FWo_N> = X''*Nx>

   (102) Pcm.Translate(Rcm,-LongueurPendule*py>)
-> (103) p_Rcm_Pcm> = -LongueurPendule*Py>
-> (104) v_Pcm_N> = X'*Nx> + LongueurPendule*q'*Px>
-> (105) a_Pcm_N> = X''*Nx> + LongueurPendule*q''*Px> + LongueurPendule*q'^2*Py>

   (106) S.Translate(Pcm,-HauteurSapin/2*py>)
-> (107) p_Pcm_S> = -0.5*HauteurSapin*Py>
-> (108) v_S_N> = X'*Nx> + 0.5*(HauteurSapin+2*LongueurPendule)*q'*Px>
-> (109) a_S_N> = X''*Nx> + 0.5*(HauteurSapin+2*LongueurPendule)*q''*Px> + 0.5*
         (HauteurSapin+2*LongueurPendule)*q'^2*Py>

   (110) B.Translate(Rcm,distBatMilieu*rx>)
-> (111) p_Rcm_B> = distBatMilieu*Rx>
-> (112) v_B_N> = X'*Nx>
-> (113) a_B_N> = X''*Nx>

   (114) M.Translate(Rcm,-distMotMilieu*rx>)
-> (115) p_Rcm_M> = -distMotMilieu*Rx>
-> (116) v_M_N> = X'*Nx>
-> (117) a_M_N> = X''*Nx>

   (118) VT> = Rcm.Getunitvector(Pcm)
-> (119) VT> = LongueurPendule/abs(LongueurPendule)*Py>

   (120) %AddForces
   (121) Rcm.AddForce(tension*VT>)
-> (122) Force_Rcm> = LongueurPendule*tension/abs(LongueurPendule)*Py>

   (123) Rcm.AddForce(-MasseRobot*g*ny>)
-> (124) Force_Rcm> = -g*MasseRobot*Ny> + LongueurPendule*tension/abs(Longueur
         Pendule)*Py>

   (125) Pcm.AddForce(-tension*VT>)
-> (126) Force_Pcm> = -LongueurPendule*tension/abs(LongueurPendule)*Py>

   (127) Pcm.AddForce(-MassePrehenseur*g*ny>)
-> (128) Force_Pcm> = -g*MassePrehenseur*Ny> - LongueurPendule*tension/abs(Lon
         gueurPendule)*Py>

   (129) RWcm.AddForce(-MasseRW*g*ny>)
-> (130) Force_RWcm> = -g*MasseRW*Ny>

   (131) FWcm.AddForce(-MasseFW*g*ny>)
-> (132) Force_FWcm> = -g*MasseFW*Ny>

   (133) Fwo.AddForce(Ng*ny>)
-> (134) Force_FWo> = Ng*Ny>

   (135) Rwo.AddForce(Nd*ny>)
-> (136) Force_RWo> = Nd*Ny>

   (137) Rwo.AddForce(fg*ny>)
-> (138) Force_RWo> = (fg+Nd)*Ny>

   (139) Fwo.AddForce(fd*ny>)
-> (140) Force_FWo> = (fd+Ng)*Ny>

   (141) S.AddForce(-MasseSapin*g*ny>)
-> (142) Force_S> = -g*MasseSapin*Ny>

   (143) B.AddForce(-MasseBatterie*g*ny>)
-> (144) Force_B> = -g*MasseBatterie*Ny>

   (145) M.AddForce(-MasseMoteur*g*ny>)
-> (146) Force_M> = -g*MasseMoteur*Ny>

   (147) %Ecm.AddForce(-MassePendule*g*ny>)
   (148) %Eo.AddForce(-tension*VT>)
   (149) %EP.AddForce(tension*VT>)
   (150) %AddTorques
   (151) RW.AddTorque(torque*nz>)
-> (152) Torque_RW> = torque*Nz>

   (153) %Ã‰quations
   (154) eq[1] = dot(S1.Getdynamics(),nx>)
-> (155) eq[1] = LongueurPendule*tension*sin(q)/abs(LongueurPendule) + (MasseB
         atterie+MasseFW+MasseMoteur+MasseRobot+MasseRW)*X''

   (156) eq[2] = dot(S1.Getdynamics(),ny>)
-> (157) eq[2] = g*MasseBatterie + g*MasseFW + g*MasseMoteur + g*MasseRobot
         + g*MasseRW - fd - fg - Nd - Ng - LongueurPendule*tension*cos(q)/abs(
         LongueurPendule)

   (158) eq[3] = dot(S1.Getdynamics(Rcm),nz>)
-> (159) eq[3] = distBatMilieu*g*MasseBatterie + distRWM*g*MasseFW + distRWM*(
         fg+Nd) - torque - distMotMilieu*g*MasseMoteur - distRWM*g*MasseRW - 
         distRWM*(fd+Ng)

   (160) eq[4] = dot(S2.Getdynamics(),nx>)
-> (161) eq[4] = (MassePrehenseur+MasseSapin)*X'' + 0.5*(2*LongueurPendule*Mas
         sePrehenseur+MasseSapin*(HauteurSapin+2*LongueurPendule))*cos(q)*q''
         - 0.5*sin(q)*(2*LongueurPendule*tension/abs(LongueurPendule)+2*Longue
         urPendule*MassePrehenseur*q'^2+MasseSapin*(HauteurSapin+2*LongueurPen
         dule)*q'^2)

   (162) eq[5] = dot(S2.Getdynamics(),ny>)
-> (163) eq[5] = g*(MassePrehenseur+MasseSapin) + 0.5*cos(q)*(2*LongueurPendule
         *tension/abs(LongueurPendule)+2*LongueurPendule*MassePrehenseur*q'^2+
         MasseSapin*(HauteurSapin+2*LongueurPendule)*q'^2) + 0.5*(2*LongueurPe
         ndule*MassePrehenseur+MasseSapin*(HauteurSapin+2*LongueurPendule))*sin
         (q)*q''

   (164) eq[6] = dot(S2.Getdynamics(Pcm),nz>)
-> (165) eq[6] = InertieP*q'' + 0.25*HauteurSapin*MasseSapin*(HauteurSapin+2*
         LongueurPendule)*q'' + 0.5*HauteurSapin*MasseSapin*(g*sin(q)+cos(q)*
         X'')

   (166) eq[7] = EP.GetDistance(Rcm) - LongueurPendule
